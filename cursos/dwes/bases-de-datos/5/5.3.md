# 5.3. Medidas de protección adicionales ([↑](README.md))

_Contenido creado por Manuel Ignacio López Quintero_

Además de las consultas preparadas, la limitación de privilegios de las cuentas, el uso de procedimientos almacenados, la implementación de registros y monitoreo, la sanitización y validación de entradas según el tipo de dato esperado y emplear Content Security Policy ([CSP](https://en.wikipedia.org/wiki/Content_Security_Policy)), todas ellas vistas anteriormente, es muy importante aplicar **medidas de protección adicionales**.

Primero, es importante mencionar que el uso de `} catch (PDOException $e) { echo 'Error: ' . $e->getMessage(); }` usado en las secciones anteriores es útil para entornos de desarrollo pero no es seguro en **entornos de producción**. Este enfoque puede exponer detalles internos del sistema, como credenciales o la estructura de la base de datos, poniendo en riesgo la seguridad. En lugar de eso, se debe registrar el error en un archivo seguro y mostrar un mensaje genérico al usuario:

```php
try {
    // Código para la conexión y consulta a la base de datos
} catch (PDOException $e) {
    // Registrar el error en un archivo de log
    error_log($e->getMessage(), 3, '/var/log/app_errors.log');
    // Mostrar un mensaje genérico al usuario
    echo 'Ha ocurrido un error. Por favor, inténtelo de nuevo más tarde.';
}
```

Otra opción es manejar la `PDOException` desde un **gestor de excepciones**. Esto es particularmente útil en proyectos grandes donde se necesita una gestión centralizada y uniforme de las excepciones.

Una práctica destacada es el uso de **variables de entorno** para guardar las credenciales de conexión a la base de datos. Almacenar directamente las credenciales en el código fuente puede ser peligroso, ya que facilita el acceso a cualquier persona que tenga acceso al repositorio de código. En su lugar, las credenciales deben guardarse en un archivo de configuración que no esté incluido en el control de versiones. Por ejemplo, en PHP se puede usar la función `getenv()` para obtener las variables de entorno:

```php
$db_host = getenv('DB_HOST');
$db_name = getenv('DB_NAME');
$db_user = getenv('DB_USER');
$db_pass = getenv('DB_PASS');
```

Otra medida relevante es el **cifrado de datos sensibles** en la base de datos. Para proteger información como números de tarjetas de crédito o datos personales, se debe utilizar un algoritmo de cifrado robusto. La extensión `openssl` de PHP es una opción para cifrar y descifrar datos. A continuación, se muestra un ejemplo básico que debe ampliarse según las necesidades del sistema:

```php
$data = 'Información sensible';
$key = 'clave_secreta';
$encrypted_data = openssl_encrypt($data, 'AES-128-ECB', $key);
$decrypted_data = openssl_decrypt($encrypted_data, 'AES-128-ECB', $key);
```

El uso de ***hashing*** para almacenar contraseñas de usuarios en la base de datos es una técnica clave. El [*hashing*](https://en.wikipedia.org/wiki/Hash_function) convierte una contraseña en una cadena de longitud fija que no puede ser revertida a su forma original, lo que añade una capa de seguridad. Por ejemplo, PHP ofrece funciones como `password_hash()` y `password_verify()` para manejar *hashes* de contraseñas de manera segura:

```php
$password = "contraseña_segura";
// Hashea la contraseña utilizando el algoritmo BCRYPT
$hashed_password = password_hash($password, PASSWORD_BCRYPT);
// Verifica que la contraseña ingresada coincida con el Hash almacenado
$isPasswordCorrect = password_verify($password, $hashed_password);
```

Además, se debe mantener **actualizado PHP y el SGBD** con los últimos parches de seguridad. Las actualizaciones suelen incluir correcciones para vulnerabilidades conocidas que pueden ser explotadas por atacantes. No aplicar estas actualizaciones puede dejar el sistema expuesto a riesgos innecesarios.

El uso de **HTTPS** para la aplicación web garantiza que la información transmitida entre el cliente y el servidor esté cifrada. HTTPS protege contra ataques de tipo Man-in-the-Middle ([MitM](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)), asegurando que los datos no sean interceptados ni modificados durante su transmisión, como por ejemplo información sensible a guardar en la base de datos.

Para prevenir la **inserción masiva de datos** realizada por *bots*, es recomendable implementar **CAPTCHA** en los formularios. Un [CAPTCHA](https://en.wikipedia.org/wiki/CAPTCHA) añade un desafío adicional que debe ser resuelto por el usuario, dificultando los intentos automatizados de envío de datos masivos a las bases de datos.

Realizar ***backups*** regulares y seguros de bases de datos es otra medida destacada. Los *backups* permiten recuperar datos en caso de pérdida, corrupción o ataque. Es importante que estos *backups* se almacenen en ubicaciones seguras y se verifiquen periódicamente para asegurar su integridad y disponibilidad.

Existen **muchas más medidas de seguridad** para proteger una base de datos. La combinación de todas proporciona una defensa sólida contra una amplia gama de amenazas y vulnerabilidades, asegurando la integridad y confidencialidad de los datos gestionados.

## Protección de contraseñas mediante _hashing_

La **función [*hash*](https://en.wikipedia.org/wiki/Hash_function)** convierte datos en una cadena de longitud fija y cifrada, que no puede revertirse a su forma original. Este proceso se usa para almacenar contraseñas de manera segura en una base de datos. Al emplear funciones de *hashing*, como `password_hash()` en PHP, la contraseña ingresada se transforma en un *hash* irreconocible. Por ejemplo, una contraseña como `P@ssw0rd1234!` puede ser almacenada como:

```
$2y$10$E1NhtQHV8hjt9ozdd9/d6Ob3JgEfxRxfFpkZnJrkEOVsZe4EqOYw6
```

Si un atacante accede a la base de datos y obtiene los *hashes* de las contraseñas, no puede revertirlos a las contraseñas originales debido a la naturaleza unidireccional del *hashing*. Aunque intentara adivinar la contraseña original, métodos adicionales como el **[salting](https://en.wikipedia.org/wiki/Salt_%28cryptography%29)** hacen que el proceso sea extremadamente difícil. El *salt* es un valor aleatorio añadido a cada contraseña antes de aplicar el *hash*, lo que asegura que incluso contraseñas idénticas generen *hashes* diferentes. Por ejemplo, `password_hash("P@ssw0rd1234!", PASSWORD_BCRYPT)` incluye un *salt* automáticamente, fortaleciendo aún más la seguridad de la contraseña a almacenar en la base de datos.

## Recursos y lecturas recomendadas

Para obtener una visión más amplia y completa sobre la **seguridad en la base de datos**, se recomienda comenzar con la **Wikipedia**, que proporciona una buena introducción y cubre conceptos esenciales y técnicas comunes. Puedes acceder a su artículo sobre [Database Security](https://en.wikipedia.org/wiki/Database_security) para más detalles.

Además, la documentación oficial de **PHP** ofrece una sección dedicada a la seguridad en las bases de datos, que incluye prácticas recomendadas y ejemplos de código para mejorar la protección de las aplicaciones web. Puedes explorar estos recursos en [PHP Manual - Database Security](https://www.php.net/manual/en/security.database.php).

Otra fuente valiosa es **IBM**, que aborda la seguridad en las bases de datos desde una perspectiva empresarial, ofreciendo soluciones y tecnologías avanzadas para proteger datos sensibles en entornos corporativos. Más información está disponible en [IBM - Database Security](https://www.ibm.com/topics/database-security).

_Contenido creado por Manuel Ignacio López Quintero_
