# 5.2. Defensa contra Cross-Site Scripting (XSS) ([↑](README.md))

_Contenido creado por Manuel Ignacio López Quintero_

La **defensa contra Cross-Site Scripting** ([XSS](https://en.wikipedia.org/wiki/Cross-site_scripting)) es una práctica para evitar que los *scripts* maliciosos comprometan la seguridad de las aplicaciones web. El objetivo principal es asegurarse de que cualquier dato introducido por el usuario no contenga elementos maliciosos que puedan comprometer la seguridad de la aplicación o la integridad de los datos.

Primero, es importante comprender qué es un ataque XSS. El **Cross-Site Scripting** es una vulnerabilidad que permite a un atacante inyectar *scripts* maliciosos en el contenido que se muestra a otros usuarios. Estos *scripts* pueden ser utilizados para robar *cookies*, modificar la apariencia de la página web o redirigir a los usuarios a sitios web maliciosos.

Para entender cómo funciona un ataque XSS, considera el siguiente ejemplo de código PHP:

```php
// Supongamos que un usuario envía su nombre a través de un formulario
$user_input = $_POST['username'];

// Esta entrada se almacenaría en la base de datos sin sanitizarla
$stored_input = $user_input;

// Más tarde, el contenido se muestra en una página web
echo "Bienvenido, " . $stored_input . "!";
```

Si un atacante introduce el siguiente código como su nombre:

```html
<script>alert('XSS');</script>
```

La salida en la página web será:

```html
¡Bienvenido, <script>alert('XSS');</script>!
```

Esto hará que el navegador ejecute el *script*, mostrando una alerta con el mensaje *XSS*. Este es solo un ejemplo simple, pero un *script* malicioso puede incluir cualquier código que comprometa la seguridad, como robar *cookies*, registrar pulsaciones de teclas o redirigir a sitios de *phishing*.

Para prevenir los ataques XSS, es necesario filtrar todas las entradas de usuario. Esto implica **sanitizar** y **validar** los datos antes de procesarlos o almacenarlos en la base de datos. En PHP, hay varias funciones y técnicas que se pueden emplear para este propósito.

Una de las funciones más básicas y útiles en PHP es `htmlspecialchars()`. Esta función convierte caracteres especiales en entidades HTML, evitando que los *scripts* se ejecuten. Por ejemplo:

```php
$user_input = "<script>alert('XSS');</script>";
$safe_input = htmlspecialchars($user_input, ENT_QUOTES, 'UTF-8');
echo $safe_input;
```

En este ejemplo, `htmlspecialchars()` convierte los caracteres `<` y `>` en sus respectivas entidades HTML, impidiendo que el *script* se ejecute.

Otra función útil es `strip_tags()`, que elimina todas las etiquetas HTML y PHP de una cadena:

```php
$user_input = "<b>Texto en negrita</b> <script>alert('XSS');</script>";
$safe_input = strip_tags($user_input);
echo $safe_input;
```

En este caso, `strip_tags()` elimina todas las etiquetas, incluyendo el *script* malicioso, aunque también puede eliminar etiquetas válidas y necesarias para el contenido.

Al trabajar con bases de datos, se deben sanitizar y validar las entradas según su **tipo de dato esperado**. En PHP, se pueden emplear métodos como `filter_var()` para este propósito. Por ejemplo, si se espera un **entero**, se puede usar:

```php
$integer_input = filter_var($_POST['integer_input'], FILTER_SANITIZE_NUMBER_INT); // Sanitizar
$integer_input = filter_var($integer_input, FILTER_VALIDATE_INT); // Validar
```

Para un **número real** se puede usar:

```php
// Sanitizar
$float_input = filter_var($_POST['float_input'],
                          FILTER_SANITIZE_NUMBER_FLOAT, FILTER_FLAG_ALLOW_FRACTION);

$float_input = filter_var($float_input, FILTER_VALIDATE_FLOAT); // Validar
```

Para un **correo electrónico**:

```php
$email_input = filter_var($_POST['email'], FILTER_SANITIZE_EMAIL); // Sanitizar
$email_input = filter_var($email_input, FILTER_VALIDATE_EMAIL); // Validar
```

Para una **fecha**, se puede validar usando una expresión regular:

```php
$date_input = $_POST['date'];
if (preg_match("/^\d{4}-\d{2}-\d{2}$/", $date_input)) {
    // La fecha es válida
} else {
    // La fecha no es válida
}
```

El uso de `urlencode()` junto con `htmlspecialchars()` puede proporcionar una capa adicional de seguridad. Por ejemplo:

```php
$badURL = "https://example.com?param=<script>alert('XSS');</script>&name=John Doe";
$safeURL = urlencode(htmlspecialchars($badURL));
echo urldecode($safeURL);
```

En este caso, `htmlspecialchars()` convierte los caracteres especiales en entidades HTML, y luego `urlencode()` codifica estos caracteres en una cadena de texto, incluyendo espacios y otros caracteres especiales. Finalmente, `urldecode()` decodifica la URL codificada.

Una política adicional para prevenir XSS es implementar **Content Security Policy (CSP)**. CSP es una capa de seguridad que ayuda a detectar y mitigar ciertos tipos de ataques, incluyendo XSS. CSP permite a los desarrolladores especificar dominios permitidos para cargar recursos, lo que puede ayudar a prevenir la ejecución de *scripts* maliciosos. Por ejemplo, se puede definir una política CSP mediante el encabezado HTTP:

```php
header(
    "Content-Security-Policy: " .
    "default-src 'self'; " .
    "script-src 'self' https://trusted.cdn.com"
);
```

Este encabezado indica que solo se pueden cargar *scripts* desde el propio dominio (`'self'`) y desde `https://trusted.cdn.com`, bloqueando *scripts* de otros orígenes.

_Contenido creado por Manuel Ignacio López Quintero_
