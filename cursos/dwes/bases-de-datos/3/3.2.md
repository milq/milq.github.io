# 3.2. Preparación y ejecución de consultas ([↑](README.md))

_Contenido creado por Manuel Ignacio López Quintero_

En la gestión de bases de datos utilizando **PHP** y **MySQLi** orientado a objetos, la **preparación** y **ejecución** de consultas son procesos que aseguran tanto la eficiencia como la seguridad de las operaciones. La preparación de consultas implica la compilación previa de la sentencia **SQL**, mientras que la ejecución es el proceso de enviar esta consulta compilada a la base de datos con los parámetros necesarios para obtener o modificar datos.

Para preparar y ejecutar una consulta en MySQLi orientado a objetos, primero se debe crear una instancia de la clase `mysqli`. Supongamos que ya se tiene una **conexión activa** a la base de datos. El siguiente paso es usar el método `prepare()` de la instancia `mysqli`. Este método toma una consulta SQL como argumento y devuelve un objeto de la clase `mysqli_stmt`. Luego, se deben **vincular los parámetros** a la consulta preparada utilizando los métodos `bind_param()` del objeto `mysqli_stmt`. Finalmente, para ejecutar la consulta preparada, se utiliza el método `execute()` del objeto `mysqli_stmt`.

El método `prepare()` permite preparar una consulta SQL con ***placeholders***, que son marcadores de posición para los valores reales que se pasarán a la consulta más adelante. Estos *placeholders* se indican con signos de interrogación (`?`). Por ejemplo, para insertar un libro en una tabla llamada `libros`, la consulta SQL sería:

```php
$stmt = $mysqli->prepare('INSERT INTO libros (id, nombre, autor) VALUES (?, ?, ?)');
```

El método `bind_param()` se utiliza para vincular variables a los parámetros en la consulta preparada. Cada tipo de dato tiene un especificador correspondiente (`i` para enteros, `s` para cadenas, `d` para flotantes y `b` para blobs). En el ejemplo del libro, la vinculación sería:

```php
$id = 1;
$nombre = 'El Quijote';
$autor = 'Cervantes';

$stmt->bind_param('iss', $id, $nombre, $autor);
```

En este caso, `i` indica que `id` es un entero, correspondiente a la primera `?`. Luego, la `s` indica que `nombre` es una cadena, correspondiente a la segunda `?`, y la última `s` indica que `autor` también es una cadena, correspondiente a la tercera `?`.

El método `execute()` del objeto `mysqli_stmt` se utiliza para **ejecutar** la consulta previamente preparada y vinculada. Por ejemplo, después de preparar y vincular la consulta para insertar un libro, la ejecución sería simplemente:

```php
$stmt->execute();
```

En caso de que se necesite ejecutar la misma consulta varias veces con diferentes valores, la **preparación inicial** de la consulta se puede reutilizar. Esto es eficiente porque la consulta solo se compila una vez, aunque se ejecute múltiples veces. Por ejemplo, para insertar otro libro, solo se necesita cambiar los valores de las variables y ejecutar de nuevo:

```php
$id = 2;
$nombre = '1984';
$autor = 'George Orwell';

$stmt->execute();
```

Es posible pasar un ***array* de parámetros** directamente al método `execute()` en lugar de utilizar `bind_param()`. Esto puede simplificar el código en algunos casos. Por ejemplo, para actualizar un registro:

```php
$stmt = $mysqli->prepare('UPDATE libros SET nombre=?, autor=? WHERE id=?');
$stmt->execute([$nombre, $autor, $id]);
```

Otra opción que lo abarca todo es `mysqli_execute_query()`, que permite, en una sola línea, preparar la consulta, vincular los parámetros y ejecutarla. Se puede hacer de la siguiente manera:

```php
$mysqli->execute_query('DELETE FROM libros WHERE id=?', [$id]);
```

Para manejar **excepciones** y errores durante la preparación y ejecución de consultas, se puede utilizar un bloque `try`-`catch`. El bloque `try` encapsula el código que puede generar una excepción, mientras que el bloque `catch` captura y maneja la excepción si ocurre. Por ejemplo:

```php
require 'connect_db.php';

try {
    $stmt = $mysqli->prepare('INSERT INTO libros (id, nombre, autor) VALUES (?, ?, ?)');
    $stmt->bind_param('iss', $id, $nombre, $autor);
    $stmt->execute();
} catch (mysqli_sql_exception $e) {
    echo 'Error: ' . $e->getMessage();
}
```

En este código, se intenta preparar y ejecutar una consulta para insertar un libro. Si ocurre algún error durante este proceso, se captura la excepción `mysqli_sql_exception` y se muestra un mensaje de error.

Este enfoque asegura que cualquier problema que ocurra durante la interacción con la base de datos se maneje adecuadamente, proporcionando una manera de depurar y resolver problemas de manera efectiva. La utilización de `try`-`catch` junto con la preparación y ejecución de consultas en MySQLi orientado a objetos no solo mejora la **seguridad** de las aplicaciones, sino que también facilita la **gestión de errores** y la **mantenibilidad** del código.

## Ejercicio

Crea una base de datos con una tabla denominada `animales` mediante `CREATE TABLE animales (id INT PRIMARY KEY, nombre VARCHAR(50), raza VARCHAR(50));`. Luego, usando PHP con la extensión MySQLi, inserta en dicha tabla tres registros diferentes varias veces con distintos valores. Solo se debe preparar la consulta una vez para ver las ventajas de utilizar `prepare`.

### Propuesta de solución (ve esta propuesta únicamente después de resolver el ejercicio por ti mismo)

La solución consiste en realizar dos archivos PHP: `connect_db.php` para establecer la conexión con la base de datos e `index.php` para ejecutar las inserciones utilizando una consulta preparada.

Este sería el archivo `connect_db.php`:

```php
<?php

try {
    $mysqli = new mysqli('localhost', 'usuario', 'contraseña', 'base_de_datos');
} catch (mysqli_sql_exception $e) {
    echo 'Error: ' . $e->getMessage();
}
```

Este sería el archivo `index.php`:

```php
<?php

require 'connect_db.php';

try {
    $stmt = $mysqli->prepare('INSERT INTO animales (id, nombre, raza) VALUES (?, ?, ?)');

    $animales = [
        [1, 'Perro', 'Labrador'],
        [2, 'Gato', 'Siamés'],
        [3, 'Caballo', 'Árabe']
    ];

    foreach ($animales as $animal) {
        $stmt->bind_param("iss", $animal[0], $animal[1], $animal[2]);
        $stmt->execute();
    }

    echo 'Registros insertados correctamente.';
} catch (mysqli_sql_exception $e) {
    echo 'Error: ' . $e->getMessage();
}
```

_Contenido creado por Manuel Ignacio López Quintero_
